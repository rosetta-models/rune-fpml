package fpml.confirmation;

import com.google.common.collect.ImmutableList;
import com.rosetta.model.lib.RosettaModelObject;
import com.rosetta.model.lib.RosettaModelObjectBuilder;
import com.rosetta.model.lib.annotations.RosettaAttribute;
import com.rosetta.model.lib.annotations.RosettaDataType;
import com.rosetta.model.lib.meta.RosettaMetaData;
import com.rosetta.model.lib.path.RosettaPath;
import com.rosetta.model.lib.process.BuilderMerger;
import com.rosetta.model.lib.process.BuilderProcessor;
import com.rosetta.model.lib.process.Processor;
import com.rosetta.util.ListEquals;
import fpml.confirmation.TradeProcessingTimestamps;
import fpml.confirmation.TradeProcessingTimestamps.TradeProcessingTimestampsBuilder;
import fpml.confirmation.TradeProcessingTimestamps.TradeProcessingTimestampsBuilderImpl;
import fpml.confirmation.TradeProcessingTimestamps.TradeProcessingTimestampsImpl;
import fpml.confirmation.TradeTimestamp;
import fpml.confirmation.meta.TradeProcessingTimestampsMeta;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static java.util.Optional.ofNullable;

/**
 * Allows timing information about when a trade was processed and reported to be recorded.
 * @version ${project.version}
 */
@RosettaDataType(value="TradeProcessingTimestamps", builder=TradeProcessingTimestamps.TradeProcessingTimestampsBuilderImpl.class, version="${project.version}")
public interface TradeProcessingTimestamps extends RosettaModelObject {

	TradeProcessingTimestampsMeta metaData = new TradeProcessingTimestampsMeta();

	/*********************** Getter Methods  ***********************/
	/**
	 * When an order was first generated, as recorded for the first time when it was first entered by a person or generated by a trading algorithm (i.e., the first record of the order).
	 */
	ZonedDateTime getOrderEntered();
	/**
	 * The time when an order is submitted by a market participant to an execution facility, as recorded based on the timestamp of the message that was sent by the participant. If the participant records this time (i.e. it is in the participant&#39;s party trade information), it will be the time the message was sent. If the execution facility records this time (i.e. it is in the facility&#39;s party trade information), it will be the time the message was received.
	 */
	ZonedDateTime getOrderSubmitted();
	/**
	 * When the public report of this was created or received by this party. If the participant records this time (i.e. it is in the participant&#39;s party trade information), it will be the time the message was sent. If the execution records this time (i.e. it is in the facility&#39;s party trade information), it will be the time the message was received.
	 */
	ZonedDateTime getPubliclyReported();
	/**
	 * When the public report of this was most recently corrected or corrections were sent or received by this party.
	 */
	ZonedDateTime getPublicReportAccepted();
	/**
	 * When the public report of this was first accepted for submission to a regulator.
	 */
	ZonedDateTime getPublicReportUpdated();
	/**
	 * When the non-public report of this was created or received by this party.
	 */
	ZonedDateTime getNonpubliclyReported();
	/**
	 * When the non-public report of this was first accepted for submission to a regulator.
	 */
	ZonedDateTime getNonpublicReportAccepted();
	/**
	 * When the non-public report of this was most recently corrected or corrections were received by this party.
	 */
	ZonedDateTime getNonpublicReportUpdated();
	/**
	 * When this trade was supplied to a confirmation service or counterparty for confirmation.
	 */
	ZonedDateTime getSubmittedForConfirmation();
	/**
	 * When the most recent correction to this trade was supplied to a confirmation service or counterparty for confirmation.
	 */
	ZonedDateTime getUpdatedForConfirmation();
	/**
	 * When this trade was confirmed.
	 */
	ZonedDateTime getConfirmed();
	/**
	 * When this trade was supplied to a clearing service for clearing.
	 */
	ZonedDateTime getSubmittedForClearing();
	/**
	 * When the most recent correction to this trade was supplied to a clearing service for clearing.
	 */
	ZonedDateTime getUpdatedForClearing();
	/**
	 * When this trade was cleared.
	 */
	ZonedDateTime getCleared();
	/**
	 * When allocations for this trade were submitted or received by this party.
	 */
	ZonedDateTime getAllocationsSubmitted();
	/**
	 * When allocations for this trade were most recently corrected.
	 */
	ZonedDateTime getAllocationsUpdated();
	/**
	 * When allocations for this trade were completely processed.
	 */
	ZonedDateTime getAllocationsCompleted();
	/**
	 * Other timestamps for this trade. This is provisional in Recordkeeping and Transparency view and may be reviewed in a subsequent draft.
	 */
	List<? extends TradeTimestamp> getTimestamp();

	/*********************** Build Methods  ***********************/
	TradeProcessingTimestamps build();
	
	TradeProcessingTimestamps.TradeProcessingTimestampsBuilder toBuilder();
	
	static TradeProcessingTimestamps.TradeProcessingTimestampsBuilder builder() {
		return new TradeProcessingTimestamps.TradeProcessingTimestampsBuilderImpl();
	}

	/*********************** Utility Methods  ***********************/
	@Override
	default RosettaMetaData<? extends TradeProcessingTimestamps> metaData() {
		return metaData;
	}
	
	@Override
	default Class<? extends TradeProcessingTimestamps> getType() {
		return TradeProcessingTimestamps.class;
	}
	
	
	@Override
	default void process(RosettaPath path, Processor processor) {
		processor.processBasic(path.newSubPath("orderEntered"), ZonedDateTime.class, getOrderEntered(), this);
		processor.processBasic(path.newSubPath("orderSubmitted"), ZonedDateTime.class, getOrderSubmitted(), this);
		processor.processBasic(path.newSubPath("publiclyReported"), ZonedDateTime.class, getPubliclyReported(), this);
		processor.processBasic(path.newSubPath("publicReportAccepted"), ZonedDateTime.class, getPublicReportAccepted(), this);
		processor.processBasic(path.newSubPath("publicReportUpdated"), ZonedDateTime.class, getPublicReportUpdated(), this);
		processor.processBasic(path.newSubPath("nonpubliclyReported"), ZonedDateTime.class, getNonpubliclyReported(), this);
		processor.processBasic(path.newSubPath("nonpublicReportAccepted"), ZonedDateTime.class, getNonpublicReportAccepted(), this);
		processor.processBasic(path.newSubPath("nonpublicReportUpdated"), ZonedDateTime.class, getNonpublicReportUpdated(), this);
		processor.processBasic(path.newSubPath("submittedForConfirmation"), ZonedDateTime.class, getSubmittedForConfirmation(), this);
		processor.processBasic(path.newSubPath("updatedForConfirmation"), ZonedDateTime.class, getUpdatedForConfirmation(), this);
		processor.processBasic(path.newSubPath("confirmed"), ZonedDateTime.class, getConfirmed(), this);
		processor.processBasic(path.newSubPath("submittedForClearing"), ZonedDateTime.class, getSubmittedForClearing(), this);
		processor.processBasic(path.newSubPath("updatedForClearing"), ZonedDateTime.class, getUpdatedForClearing(), this);
		processor.processBasic(path.newSubPath("cleared"), ZonedDateTime.class, getCleared(), this);
		processor.processBasic(path.newSubPath("allocationsSubmitted"), ZonedDateTime.class, getAllocationsSubmitted(), this);
		processor.processBasic(path.newSubPath("allocationsUpdated"), ZonedDateTime.class, getAllocationsUpdated(), this);
		processor.processBasic(path.newSubPath("allocationsCompleted"), ZonedDateTime.class, getAllocationsCompleted(), this);
		processRosetta(path.newSubPath("timestamp"), processor, TradeTimestamp.class, getTimestamp());
	}
	

	/*********************** Builder Interface  ***********************/
	interface TradeProcessingTimestampsBuilder extends TradeProcessingTimestamps, RosettaModelObjectBuilder {
		TradeTimestamp.TradeTimestampBuilder getOrCreateTimestamp(int _index);
		List<? extends TradeTimestamp.TradeTimestampBuilder> getTimestamp();
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setOrderEntered(ZonedDateTime orderEntered);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setOrderSubmitted(ZonedDateTime orderSubmitted);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setPubliclyReported(ZonedDateTime publiclyReported);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setPublicReportAccepted(ZonedDateTime publicReportAccepted);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setPublicReportUpdated(ZonedDateTime publicReportUpdated);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setNonpubliclyReported(ZonedDateTime nonpubliclyReported);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setNonpublicReportAccepted(ZonedDateTime nonpublicReportAccepted);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setNonpublicReportUpdated(ZonedDateTime nonpublicReportUpdated);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setSubmittedForConfirmation(ZonedDateTime submittedForConfirmation);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setUpdatedForConfirmation(ZonedDateTime updatedForConfirmation);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setConfirmed(ZonedDateTime confirmed);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setSubmittedForClearing(ZonedDateTime submittedForClearing);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setUpdatedForClearing(ZonedDateTime updatedForClearing);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setCleared(ZonedDateTime cleared);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setAllocationsSubmitted(ZonedDateTime allocationsSubmitted);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setAllocationsUpdated(ZonedDateTime allocationsUpdated);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setAllocationsCompleted(ZonedDateTime allocationsCompleted);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder addTimestamp(TradeTimestamp timestamp0);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder addTimestamp(TradeTimestamp timestamp1, int _idx);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder addTimestamp(List<? extends TradeTimestamp> timestamp2);
		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setTimestamp(List<? extends TradeTimestamp> timestamp3);

		@Override
		default void process(RosettaPath path, BuilderProcessor processor) {
			processor.processBasic(path.newSubPath("orderEntered"), ZonedDateTime.class, getOrderEntered(), this);
			processor.processBasic(path.newSubPath("orderSubmitted"), ZonedDateTime.class, getOrderSubmitted(), this);
			processor.processBasic(path.newSubPath("publiclyReported"), ZonedDateTime.class, getPubliclyReported(), this);
			processor.processBasic(path.newSubPath("publicReportAccepted"), ZonedDateTime.class, getPublicReportAccepted(), this);
			processor.processBasic(path.newSubPath("publicReportUpdated"), ZonedDateTime.class, getPublicReportUpdated(), this);
			processor.processBasic(path.newSubPath("nonpubliclyReported"), ZonedDateTime.class, getNonpubliclyReported(), this);
			processor.processBasic(path.newSubPath("nonpublicReportAccepted"), ZonedDateTime.class, getNonpublicReportAccepted(), this);
			processor.processBasic(path.newSubPath("nonpublicReportUpdated"), ZonedDateTime.class, getNonpublicReportUpdated(), this);
			processor.processBasic(path.newSubPath("submittedForConfirmation"), ZonedDateTime.class, getSubmittedForConfirmation(), this);
			processor.processBasic(path.newSubPath("updatedForConfirmation"), ZonedDateTime.class, getUpdatedForConfirmation(), this);
			processor.processBasic(path.newSubPath("confirmed"), ZonedDateTime.class, getConfirmed(), this);
			processor.processBasic(path.newSubPath("submittedForClearing"), ZonedDateTime.class, getSubmittedForClearing(), this);
			processor.processBasic(path.newSubPath("updatedForClearing"), ZonedDateTime.class, getUpdatedForClearing(), this);
			processor.processBasic(path.newSubPath("cleared"), ZonedDateTime.class, getCleared(), this);
			processor.processBasic(path.newSubPath("allocationsSubmitted"), ZonedDateTime.class, getAllocationsSubmitted(), this);
			processor.processBasic(path.newSubPath("allocationsUpdated"), ZonedDateTime.class, getAllocationsUpdated(), this);
			processor.processBasic(path.newSubPath("allocationsCompleted"), ZonedDateTime.class, getAllocationsCompleted(), this);
			processRosetta(path.newSubPath("timestamp"), processor, TradeTimestamp.TradeTimestampBuilder.class, getTimestamp());
		}
		

		TradeProcessingTimestamps.TradeProcessingTimestampsBuilder prune();
	}

	/*********************** Immutable Implementation of TradeProcessingTimestamps  ***********************/
	class TradeProcessingTimestampsImpl implements TradeProcessingTimestamps {
		private final ZonedDateTime orderEntered;
		private final ZonedDateTime orderSubmitted;
		private final ZonedDateTime publiclyReported;
		private final ZonedDateTime publicReportAccepted;
		private final ZonedDateTime publicReportUpdated;
		private final ZonedDateTime nonpubliclyReported;
		private final ZonedDateTime nonpublicReportAccepted;
		private final ZonedDateTime nonpublicReportUpdated;
		private final ZonedDateTime submittedForConfirmation;
		private final ZonedDateTime updatedForConfirmation;
		private final ZonedDateTime confirmed;
		private final ZonedDateTime submittedForClearing;
		private final ZonedDateTime updatedForClearing;
		private final ZonedDateTime cleared;
		private final ZonedDateTime allocationsSubmitted;
		private final ZonedDateTime allocationsUpdated;
		private final ZonedDateTime allocationsCompleted;
		private final List<? extends TradeTimestamp> timestamp;
		
		protected TradeProcessingTimestampsImpl(TradeProcessingTimestamps.TradeProcessingTimestampsBuilder builder) {
			this.orderEntered = builder.getOrderEntered();
			this.orderSubmitted = builder.getOrderSubmitted();
			this.publiclyReported = builder.getPubliclyReported();
			this.publicReportAccepted = builder.getPublicReportAccepted();
			this.publicReportUpdated = builder.getPublicReportUpdated();
			this.nonpubliclyReported = builder.getNonpubliclyReported();
			this.nonpublicReportAccepted = builder.getNonpublicReportAccepted();
			this.nonpublicReportUpdated = builder.getNonpublicReportUpdated();
			this.submittedForConfirmation = builder.getSubmittedForConfirmation();
			this.updatedForConfirmation = builder.getUpdatedForConfirmation();
			this.confirmed = builder.getConfirmed();
			this.submittedForClearing = builder.getSubmittedForClearing();
			this.updatedForClearing = builder.getUpdatedForClearing();
			this.cleared = builder.getCleared();
			this.allocationsSubmitted = builder.getAllocationsSubmitted();
			this.allocationsUpdated = builder.getAllocationsUpdated();
			this.allocationsCompleted = builder.getAllocationsCompleted();
			this.timestamp = ofNullable(builder.getTimestamp()).filter(_l->!_l.isEmpty()).map(list -> list.stream().filter(Objects::nonNull).map(f->f.build()).filter(Objects::nonNull).collect(ImmutableList.toImmutableList())).orElse(null);
		}
		
		@Override
		@RosettaAttribute("orderEntered")
		public ZonedDateTime getOrderEntered() {
			return orderEntered;
		}
		
		@Override
		@RosettaAttribute("orderSubmitted")
		public ZonedDateTime getOrderSubmitted() {
			return orderSubmitted;
		}
		
		@Override
		@RosettaAttribute("publiclyReported")
		public ZonedDateTime getPubliclyReported() {
			return publiclyReported;
		}
		
		@Override
		@RosettaAttribute("publicReportAccepted")
		public ZonedDateTime getPublicReportAccepted() {
			return publicReportAccepted;
		}
		
		@Override
		@RosettaAttribute("publicReportUpdated")
		public ZonedDateTime getPublicReportUpdated() {
			return publicReportUpdated;
		}
		
		@Override
		@RosettaAttribute("nonpubliclyReported")
		public ZonedDateTime getNonpubliclyReported() {
			return nonpubliclyReported;
		}
		
		@Override
		@RosettaAttribute("nonpublicReportAccepted")
		public ZonedDateTime getNonpublicReportAccepted() {
			return nonpublicReportAccepted;
		}
		
		@Override
		@RosettaAttribute("nonpublicReportUpdated")
		public ZonedDateTime getNonpublicReportUpdated() {
			return nonpublicReportUpdated;
		}
		
		@Override
		@RosettaAttribute("submittedForConfirmation")
		public ZonedDateTime getSubmittedForConfirmation() {
			return submittedForConfirmation;
		}
		
		@Override
		@RosettaAttribute("updatedForConfirmation")
		public ZonedDateTime getUpdatedForConfirmation() {
			return updatedForConfirmation;
		}
		
		@Override
		@RosettaAttribute("confirmed")
		public ZonedDateTime getConfirmed() {
			return confirmed;
		}
		
		@Override
		@RosettaAttribute("submittedForClearing")
		public ZonedDateTime getSubmittedForClearing() {
			return submittedForClearing;
		}
		
		@Override
		@RosettaAttribute("updatedForClearing")
		public ZonedDateTime getUpdatedForClearing() {
			return updatedForClearing;
		}
		
		@Override
		@RosettaAttribute("cleared")
		public ZonedDateTime getCleared() {
			return cleared;
		}
		
		@Override
		@RosettaAttribute("allocationsSubmitted")
		public ZonedDateTime getAllocationsSubmitted() {
			return allocationsSubmitted;
		}
		
		@Override
		@RosettaAttribute("allocationsUpdated")
		public ZonedDateTime getAllocationsUpdated() {
			return allocationsUpdated;
		}
		
		@Override
		@RosettaAttribute("allocationsCompleted")
		public ZonedDateTime getAllocationsCompleted() {
			return allocationsCompleted;
		}
		
		@Override
		@RosettaAttribute("timestamp")
		public List<? extends TradeTimestamp> getTimestamp() {
			return timestamp;
		}
		
		@Override
		public TradeProcessingTimestamps build() {
			return this;
		}
		
		@Override
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder toBuilder() {
			TradeProcessingTimestamps.TradeProcessingTimestampsBuilder builder = builder();
			setBuilderFields(builder);
			return builder;
		}
		
		protected void setBuilderFields(TradeProcessingTimestamps.TradeProcessingTimestampsBuilder builder) {
			ofNullable(getOrderEntered()).ifPresent(builder::setOrderEntered);
			ofNullable(getOrderSubmitted()).ifPresent(builder::setOrderSubmitted);
			ofNullable(getPubliclyReported()).ifPresent(builder::setPubliclyReported);
			ofNullable(getPublicReportAccepted()).ifPresent(builder::setPublicReportAccepted);
			ofNullable(getPublicReportUpdated()).ifPresent(builder::setPublicReportUpdated);
			ofNullable(getNonpubliclyReported()).ifPresent(builder::setNonpubliclyReported);
			ofNullable(getNonpublicReportAccepted()).ifPresent(builder::setNonpublicReportAccepted);
			ofNullable(getNonpublicReportUpdated()).ifPresent(builder::setNonpublicReportUpdated);
			ofNullable(getSubmittedForConfirmation()).ifPresent(builder::setSubmittedForConfirmation);
			ofNullable(getUpdatedForConfirmation()).ifPresent(builder::setUpdatedForConfirmation);
			ofNullable(getConfirmed()).ifPresent(builder::setConfirmed);
			ofNullable(getSubmittedForClearing()).ifPresent(builder::setSubmittedForClearing);
			ofNullable(getUpdatedForClearing()).ifPresent(builder::setUpdatedForClearing);
			ofNullable(getCleared()).ifPresent(builder::setCleared);
			ofNullable(getAllocationsSubmitted()).ifPresent(builder::setAllocationsSubmitted);
			ofNullable(getAllocationsUpdated()).ifPresent(builder::setAllocationsUpdated);
			ofNullable(getAllocationsCompleted()).ifPresent(builder::setAllocationsCompleted);
			ofNullable(getTimestamp()).ifPresent(builder::setTimestamp);
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || !(o instanceof RosettaModelObject) || !getType().equals(((RosettaModelObject)o).getType())) return false;
		
			TradeProcessingTimestamps _that = getType().cast(o);
		
			if (!Objects.equals(orderEntered, _that.getOrderEntered())) return false;
			if (!Objects.equals(orderSubmitted, _that.getOrderSubmitted())) return false;
			if (!Objects.equals(publiclyReported, _that.getPubliclyReported())) return false;
			if (!Objects.equals(publicReportAccepted, _that.getPublicReportAccepted())) return false;
			if (!Objects.equals(publicReportUpdated, _that.getPublicReportUpdated())) return false;
			if (!Objects.equals(nonpubliclyReported, _that.getNonpubliclyReported())) return false;
			if (!Objects.equals(nonpublicReportAccepted, _that.getNonpublicReportAccepted())) return false;
			if (!Objects.equals(nonpublicReportUpdated, _that.getNonpublicReportUpdated())) return false;
			if (!Objects.equals(submittedForConfirmation, _that.getSubmittedForConfirmation())) return false;
			if (!Objects.equals(updatedForConfirmation, _that.getUpdatedForConfirmation())) return false;
			if (!Objects.equals(confirmed, _that.getConfirmed())) return false;
			if (!Objects.equals(submittedForClearing, _that.getSubmittedForClearing())) return false;
			if (!Objects.equals(updatedForClearing, _that.getUpdatedForClearing())) return false;
			if (!Objects.equals(cleared, _that.getCleared())) return false;
			if (!Objects.equals(allocationsSubmitted, _that.getAllocationsSubmitted())) return false;
			if (!Objects.equals(allocationsUpdated, _that.getAllocationsUpdated())) return false;
			if (!Objects.equals(allocationsCompleted, _that.getAllocationsCompleted())) return false;
			if (!ListEquals.listEquals(timestamp, _that.getTimestamp())) return false;
			return true;
		}
		
		@Override
		public int hashCode() {
			int _result = 0;
			_result = 31 * _result + (orderEntered != null ? orderEntered.hashCode() : 0);
			_result = 31 * _result + (orderSubmitted != null ? orderSubmitted.hashCode() : 0);
			_result = 31 * _result + (publiclyReported != null ? publiclyReported.hashCode() : 0);
			_result = 31 * _result + (publicReportAccepted != null ? publicReportAccepted.hashCode() : 0);
			_result = 31 * _result + (publicReportUpdated != null ? publicReportUpdated.hashCode() : 0);
			_result = 31 * _result + (nonpubliclyReported != null ? nonpubliclyReported.hashCode() : 0);
			_result = 31 * _result + (nonpublicReportAccepted != null ? nonpublicReportAccepted.hashCode() : 0);
			_result = 31 * _result + (nonpublicReportUpdated != null ? nonpublicReportUpdated.hashCode() : 0);
			_result = 31 * _result + (submittedForConfirmation != null ? submittedForConfirmation.hashCode() : 0);
			_result = 31 * _result + (updatedForConfirmation != null ? updatedForConfirmation.hashCode() : 0);
			_result = 31 * _result + (confirmed != null ? confirmed.hashCode() : 0);
			_result = 31 * _result + (submittedForClearing != null ? submittedForClearing.hashCode() : 0);
			_result = 31 * _result + (updatedForClearing != null ? updatedForClearing.hashCode() : 0);
			_result = 31 * _result + (cleared != null ? cleared.hashCode() : 0);
			_result = 31 * _result + (allocationsSubmitted != null ? allocationsSubmitted.hashCode() : 0);
			_result = 31 * _result + (allocationsUpdated != null ? allocationsUpdated.hashCode() : 0);
			_result = 31 * _result + (allocationsCompleted != null ? allocationsCompleted.hashCode() : 0);
			_result = 31 * _result + (timestamp != null ? timestamp.hashCode() : 0);
			return _result;
		}
		
		@Override
		public String toString() {
			return "TradeProcessingTimestamps {" +
				"orderEntered=" + this.orderEntered + ", " +
				"orderSubmitted=" + this.orderSubmitted + ", " +
				"publiclyReported=" + this.publiclyReported + ", " +
				"publicReportAccepted=" + this.publicReportAccepted + ", " +
				"publicReportUpdated=" + this.publicReportUpdated + ", " +
				"nonpubliclyReported=" + this.nonpubliclyReported + ", " +
				"nonpublicReportAccepted=" + this.nonpublicReportAccepted + ", " +
				"nonpublicReportUpdated=" + this.nonpublicReportUpdated + ", " +
				"submittedForConfirmation=" + this.submittedForConfirmation + ", " +
				"updatedForConfirmation=" + this.updatedForConfirmation + ", " +
				"confirmed=" + this.confirmed + ", " +
				"submittedForClearing=" + this.submittedForClearing + ", " +
				"updatedForClearing=" + this.updatedForClearing + ", " +
				"cleared=" + this.cleared + ", " +
				"allocationsSubmitted=" + this.allocationsSubmitted + ", " +
				"allocationsUpdated=" + this.allocationsUpdated + ", " +
				"allocationsCompleted=" + this.allocationsCompleted + ", " +
				"timestamp=" + this.timestamp +
			'}';
		}
	}

	/*********************** Builder Implementation of TradeProcessingTimestamps  ***********************/
	class TradeProcessingTimestampsBuilderImpl implements TradeProcessingTimestamps.TradeProcessingTimestampsBuilder {
	
		protected ZonedDateTime orderEntered;
		protected ZonedDateTime orderSubmitted;
		protected ZonedDateTime publiclyReported;
		protected ZonedDateTime publicReportAccepted;
		protected ZonedDateTime publicReportUpdated;
		protected ZonedDateTime nonpubliclyReported;
		protected ZonedDateTime nonpublicReportAccepted;
		protected ZonedDateTime nonpublicReportUpdated;
		protected ZonedDateTime submittedForConfirmation;
		protected ZonedDateTime updatedForConfirmation;
		protected ZonedDateTime confirmed;
		protected ZonedDateTime submittedForClearing;
		protected ZonedDateTime updatedForClearing;
		protected ZonedDateTime cleared;
		protected ZonedDateTime allocationsSubmitted;
		protected ZonedDateTime allocationsUpdated;
		protected ZonedDateTime allocationsCompleted;
		protected List<TradeTimestamp.TradeTimestampBuilder> timestamp = new ArrayList<>();
	
		public TradeProcessingTimestampsBuilderImpl() {
		}
	
		@Override
		@RosettaAttribute("orderEntered")
		public ZonedDateTime getOrderEntered() {
			return orderEntered;
		}
		
		@Override
		@RosettaAttribute("orderSubmitted")
		public ZonedDateTime getOrderSubmitted() {
			return orderSubmitted;
		}
		
		@Override
		@RosettaAttribute("publiclyReported")
		public ZonedDateTime getPubliclyReported() {
			return publiclyReported;
		}
		
		@Override
		@RosettaAttribute("publicReportAccepted")
		public ZonedDateTime getPublicReportAccepted() {
			return publicReportAccepted;
		}
		
		@Override
		@RosettaAttribute("publicReportUpdated")
		public ZonedDateTime getPublicReportUpdated() {
			return publicReportUpdated;
		}
		
		@Override
		@RosettaAttribute("nonpubliclyReported")
		public ZonedDateTime getNonpubliclyReported() {
			return nonpubliclyReported;
		}
		
		@Override
		@RosettaAttribute("nonpublicReportAccepted")
		public ZonedDateTime getNonpublicReportAccepted() {
			return nonpublicReportAccepted;
		}
		
		@Override
		@RosettaAttribute("nonpublicReportUpdated")
		public ZonedDateTime getNonpublicReportUpdated() {
			return nonpublicReportUpdated;
		}
		
		@Override
		@RosettaAttribute("submittedForConfirmation")
		public ZonedDateTime getSubmittedForConfirmation() {
			return submittedForConfirmation;
		}
		
		@Override
		@RosettaAttribute("updatedForConfirmation")
		public ZonedDateTime getUpdatedForConfirmation() {
			return updatedForConfirmation;
		}
		
		@Override
		@RosettaAttribute("confirmed")
		public ZonedDateTime getConfirmed() {
			return confirmed;
		}
		
		@Override
		@RosettaAttribute("submittedForClearing")
		public ZonedDateTime getSubmittedForClearing() {
			return submittedForClearing;
		}
		
		@Override
		@RosettaAttribute("updatedForClearing")
		public ZonedDateTime getUpdatedForClearing() {
			return updatedForClearing;
		}
		
		@Override
		@RosettaAttribute("cleared")
		public ZonedDateTime getCleared() {
			return cleared;
		}
		
		@Override
		@RosettaAttribute("allocationsSubmitted")
		public ZonedDateTime getAllocationsSubmitted() {
			return allocationsSubmitted;
		}
		
		@Override
		@RosettaAttribute("allocationsUpdated")
		public ZonedDateTime getAllocationsUpdated() {
			return allocationsUpdated;
		}
		
		@Override
		@RosettaAttribute("allocationsCompleted")
		public ZonedDateTime getAllocationsCompleted() {
			return allocationsCompleted;
		}
		
		@Override
		@RosettaAttribute("timestamp")
		public List<? extends TradeTimestamp.TradeTimestampBuilder> getTimestamp() {
			return timestamp;
		}
		
		public TradeTimestamp.TradeTimestampBuilder getOrCreateTimestamp(int _index) {
		
			if (timestamp==null) {
				this.timestamp = new ArrayList<>();
			}
			TradeTimestamp.TradeTimestampBuilder result;
			return getIndex(timestamp, _index, () -> {
						TradeTimestamp.TradeTimestampBuilder newTimestamp = TradeTimestamp.builder();
						return newTimestamp;
					});
		}
		
		@Override
		@RosettaAttribute("orderEntered")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setOrderEntered(ZonedDateTime orderEntered) {
			this.orderEntered = orderEntered==null?null:orderEntered;
			return this;
		}
		@Override
		@RosettaAttribute("orderSubmitted")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setOrderSubmitted(ZonedDateTime orderSubmitted) {
			this.orderSubmitted = orderSubmitted==null?null:orderSubmitted;
			return this;
		}
		@Override
		@RosettaAttribute("publiclyReported")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setPubliclyReported(ZonedDateTime publiclyReported) {
			this.publiclyReported = publiclyReported==null?null:publiclyReported;
			return this;
		}
		@Override
		@RosettaAttribute("publicReportAccepted")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setPublicReportAccepted(ZonedDateTime publicReportAccepted) {
			this.publicReportAccepted = publicReportAccepted==null?null:publicReportAccepted;
			return this;
		}
		@Override
		@RosettaAttribute("publicReportUpdated")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setPublicReportUpdated(ZonedDateTime publicReportUpdated) {
			this.publicReportUpdated = publicReportUpdated==null?null:publicReportUpdated;
			return this;
		}
		@Override
		@RosettaAttribute("nonpubliclyReported")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setNonpubliclyReported(ZonedDateTime nonpubliclyReported) {
			this.nonpubliclyReported = nonpubliclyReported==null?null:nonpubliclyReported;
			return this;
		}
		@Override
		@RosettaAttribute("nonpublicReportAccepted")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setNonpublicReportAccepted(ZonedDateTime nonpublicReportAccepted) {
			this.nonpublicReportAccepted = nonpublicReportAccepted==null?null:nonpublicReportAccepted;
			return this;
		}
		@Override
		@RosettaAttribute("nonpublicReportUpdated")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setNonpublicReportUpdated(ZonedDateTime nonpublicReportUpdated) {
			this.nonpublicReportUpdated = nonpublicReportUpdated==null?null:nonpublicReportUpdated;
			return this;
		}
		@Override
		@RosettaAttribute("submittedForConfirmation")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setSubmittedForConfirmation(ZonedDateTime submittedForConfirmation) {
			this.submittedForConfirmation = submittedForConfirmation==null?null:submittedForConfirmation;
			return this;
		}
		@Override
		@RosettaAttribute("updatedForConfirmation")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setUpdatedForConfirmation(ZonedDateTime updatedForConfirmation) {
			this.updatedForConfirmation = updatedForConfirmation==null?null:updatedForConfirmation;
			return this;
		}
		@Override
		@RosettaAttribute("confirmed")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setConfirmed(ZonedDateTime confirmed) {
			this.confirmed = confirmed==null?null:confirmed;
			return this;
		}
		@Override
		@RosettaAttribute("submittedForClearing")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setSubmittedForClearing(ZonedDateTime submittedForClearing) {
			this.submittedForClearing = submittedForClearing==null?null:submittedForClearing;
			return this;
		}
		@Override
		@RosettaAttribute("updatedForClearing")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setUpdatedForClearing(ZonedDateTime updatedForClearing) {
			this.updatedForClearing = updatedForClearing==null?null:updatedForClearing;
			return this;
		}
		@Override
		@RosettaAttribute("cleared")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setCleared(ZonedDateTime cleared) {
			this.cleared = cleared==null?null:cleared;
			return this;
		}
		@Override
		@RosettaAttribute("allocationsSubmitted")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setAllocationsSubmitted(ZonedDateTime allocationsSubmitted) {
			this.allocationsSubmitted = allocationsSubmitted==null?null:allocationsSubmitted;
			return this;
		}
		@Override
		@RosettaAttribute("allocationsUpdated")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setAllocationsUpdated(ZonedDateTime allocationsUpdated) {
			this.allocationsUpdated = allocationsUpdated==null?null:allocationsUpdated;
			return this;
		}
		@Override
		@RosettaAttribute("allocationsCompleted")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setAllocationsCompleted(ZonedDateTime allocationsCompleted) {
			this.allocationsCompleted = allocationsCompleted==null?null:allocationsCompleted;
			return this;
		}
		@Override
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder addTimestamp(TradeTimestamp timestamp) {
			if (timestamp!=null) this.timestamp.add(timestamp.toBuilder());
			return this;
		}
		
		@Override
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder addTimestamp(TradeTimestamp timestamp, int _idx) {
			getIndex(this.timestamp, _idx, () -> timestamp.toBuilder());
			return this;
		}
		@Override 
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder addTimestamp(List<? extends TradeTimestamp> timestamps) {
			if (timestamps != null) {
				for (TradeTimestamp toAdd : timestamps) {
					this.timestamp.add(toAdd.toBuilder());
				}
			}
			return this;
		}
		
		@Override 
		@RosettaAttribute("timestamp")
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder setTimestamp(List<? extends TradeTimestamp> timestamps) {
			if (timestamps == null)  {
				this.timestamp = new ArrayList<>();
			}
			else {
				this.timestamp = timestamps.stream()
					.map(_a->_a.toBuilder())
					.collect(Collectors.toCollection(()->new ArrayList<>()));
			}
			return this;
		}
		
		
		@Override
		public TradeProcessingTimestamps build() {
			return new TradeProcessingTimestamps.TradeProcessingTimestampsImpl(this);
		}
		
		@Override
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder toBuilder() {
			return this;
		}
	
		@SuppressWarnings("unchecked")
		@Override
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder prune() {
			timestamp = timestamp.stream().filter(b->b!=null).<TradeTimestamp.TradeTimestampBuilder>map(b->b.prune()).filter(b->b.hasData()).collect(Collectors.toList());
			return this;
		}
		
		@Override
		public boolean hasData() {
			if (getOrderEntered()!=null) return true;
			if (getOrderSubmitted()!=null) return true;
			if (getPubliclyReported()!=null) return true;
			if (getPublicReportAccepted()!=null) return true;
			if (getPublicReportUpdated()!=null) return true;
			if (getNonpubliclyReported()!=null) return true;
			if (getNonpublicReportAccepted()!=null) return true;
			if (getNonpublicReportUpdated()!=null) return true;
			if (getSubmittedForConfirmation()!=null) return true;
			if (getUpdatedForConfirmation()!=null) return true;
			if (getConfirmed()!=null) return true;
			if (getSubmittedForClearing()!=null) return true;
			if (getUpdatedForClearing()!=null) return true;
			if (getCleared()!=null) return true;
			if (getAllocationsSubmitted()!=null) return true;
			if (getAllocationsUpdated()!=null) return true;
			if (getAllocationsCompleted()!=null) return true;
			if (getTimestamp()!=null && getTimestamp().stream().filter(Objects::nonNull).anyMatch(a->a.hasData())) return true;
			return false;
		}
	
		@SuppressWarnings("unchecked")
		@Override
		public TradeProcessingTimestamps.TradeProcessingTimestampsBuilder merge(RosettaModelObjectBuilder other, BuilderMerger merger) {
			TradeProcessingTimestamps.TradeProcessingTimestampsBuilder o = (TradeProcessingTimestamps.TradeProcessingTimestampsBuilder) other;
			
			merger.mergeRosetta(getTimestamp(), o.getTimestamp(), this::getOrCreateTimestamp);
			
			merger.mergeBasic(getOrderEntered(), o.getOrderEntered(), this::setOrderEntered);
			merger.mergeBasic(getOrderSubmitted(), o.getOrderSubmitted(), this::setOrderSubmitted);
			merger.mergeBasic(getPubliclyReported(), o.getPubliclyReported(), this::setPubliclyReported);
			merger.mergeBasic(getPublicReportAccepted(), o.getPublicReportAccepted(), this::setPublicReportAccepted);
			merger.mergeBasic(getPublicReportUpdated(), o.getPublicReportUpdated(), this::setPublicReportUpdated);
			merger.mergeBasic(getNonpubliclyReported(), o.getNonpubliclyReported(), this::setNonpubliclyReported);
			merger.mergeBasic(getNonpublicReportAccepted(), o.getNonpublicReportAccepted(), this::setNonpublicReportAccepted);
			merger.mergeBasic(getNonpublicReportUpdated(), o.getNonpublicReportUpdated(), this::setNonpublicReportUpdated);
			merger.mergeBasic(getSubmittedForConfirmation(), o.getSubmittedForConfirmation(), this::setSubmittedForConfirmation);
			merger.mergeBasic(getUpdatedForConfirmation(), o.getUpdatedForConfirmation(), this::setUpdatedForConfirmation);
			merger.mergeBasic(getConfirmed(), o.getConfirmed(), this::setConfirmed);
			merger.mergeBasic(getSubmittedForClearing(), o.getSubmittedForClearing(), this::setSubmittedForClearing);
			merger.mergeBasic(getUpdatedForClearing(), o.getUpdatedForClearing(), this::setUpdatedForClearing);
			merger.mergeBasic(getCleared(), o.getCleared(), this::setCleared);
			merger.mergeBasic(getAllocationsSubmitted(), o.getAllocationsSubmitted(), this::setAllocationsSubmitted);
			merger.mergeBasic(getAllocationsUpdated(), o.getAllocationsUpdated(), this::setAllocationsUpdated);
			merger.mergeBasic(getAllocationsCompleted(), o.getAllocationsCompleted(), this::setAllocationsCompleted);
			return this;
		}
	
		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || !(o instanceof RosettaModelObject) || !getType().equals(((RosettaModelObject)o).getType())) return false;
		
			TradeProcessingTimestamps _that = getType().cast(o);
		
			if (!Objects.equals(orderEntered, _that.getOrderEntered())) return false;
			if (!Objects.equals(orderSubmitted, _that.getOrderSubmitted())) return false;
			if (!Objects.equals(publiclyReported, _that.getPubliclyReported())) return false;
			if (!Objects.equals(publicReportAccepted, _that.getPublicReportAccepted())) return false;
			if (!Objects.equals(publicReportUpdated, _that.getPublicReportUpdated())) return false;
			if (!Objects.equals(nonpubliclyReported, _that.getNonpubliclyReported())) return false;
			if (!Objects.equals(nonpublicReportAccepted, _that.getNonpublicReportAccepted())) return false;
			if (!Objects.equals(nonpublicReportUpdated, _that.getNonpublicReportUpdated())) return false;
			if (!Objects.equals(submittedForConfirmation, _that.getSubmittedForConfirmation())) return false;
			if (!Objects.equals(updatedForConfirmation, _that.getUpdatedForConfirmation())) return false;
			if (!Objects.equals(confirmed, _that.getConfirmed())) return false;
			if (!Objects.equals(submittedForClearing, _that.getSubmittedForClearing())) return false;
			if (!Objects.equals(updatedForClearing, _that.getUpdatedForClearing())) return false;
			if (!Objects.equals(cleared, _that.getCleared())) return false;
			if (!Objects.equals(allocationsSubmitted, _that.getAllocationsSubmitted())) return false;
			if (!Objects.equals(allocationsUpdated, _that.getAllocationsUpdated())) return false;
			if (!Objects.equals(allocationsCompleted, _that.getAllocationsCompleted())) return false;
			if (!ListEquals.listEquals(timestamp, _that.getTimestamp())) return false;
			return true;
		}
		
		@Override
		public int hashCode() {
			int _result = 0;
			_result = 31 * _result + (orderEntered != null ? orderEntered.hashCode() : 0);
			_result = 31 * _result + (orderSubmitted != null ? orderSubmitted.hashCode() : 0);
			_result = 31 * _result + (publiclyReported != null ? publiclyReported.hashCode() : 0);
			_result = 31 * _result + (publicReportAccepted != null ? publicReportAccepted.hashCode() : 0);
			_result = 31 * _result + (publicReportUpdated != null ? publicReportUpdated.hashCode() : 0);
			_result = 31 * _result + (nonpubliclyReported != null ? nonpubliclyReported.hashCode() : 0);
			_result = 31 * _result + (nonpublicReportAccepted != null ? nonpublicReportAccepted.hashCode() : 0);
			_result = 31 * _result + (nonpublicReportUpdated != null ? nonpublicReportUpdated.hashCode() : 0);
			_result = 31 * _result + (submittedForConfirmation != null ? submittedForConfirmation.hashCode() : 0);
			_result = 31 * _result + (updatedForConfirmation != null ? updatedForConfirmation.hashCode() : 0);
			_result = 31 * _result + (confirmed != null ? confirmed.hashCode() : 0);
			_result = 31 * _result + (submittedForClearing != null ? submittedForClearing.hashCode() : 0);
			_result = 31 * _result + (updatedForClearing != null ? updatedForClearing.hashCode() : 0);
			_result = 31 * _result + (cleared != null ? cleared.hashCode() : 0);
			_result = 31 * _result + (allocationsSubmitted != null ? allocationsSubmitted.hashCode() : 0);
			_result = 31 * _result + (allocationsUpdated != null ? allocationsUpdated.hashCode() : 0);
			_result = 31 * _result + (allocationsCompleted != null ? allocationsCompleted.hashCode() : 0);
			_result = 31 * _result + (timestamp != null ? timestamp.hashCode() : 0);
			return _result;
		}
		
		@Override
		public String toString() {
			return "TradeProcessingTimestampsBuilder {" +
				"orderEntered=" + this.orderEntered + ", " +
				"orderSubmitted=" + this.orderSubmitted + ", " +
				"publiclyReported=" + this.publiclyReported + ", " +
				"publicReportAccepted=" + this.publicReportAccepted + ", " +
				"publicReportUpdated=" + this.publicReportUpdated + ", " +
				"nonpubliclyReported=" + this.nonpubliclyReported + ", " +
				"nonpublicReportAccepted=" + this.nonpublicReportAccepted + ", " +
				"nonpublicReportUpdated=" + this.nonpublicReportUpdated + ", " +
				"submittedForConfirmation=" + this.submittedForConfirmation + ", " +
				"updatedForConfirmation=" + this.updatedForConfirmation + ", " +
				"confirmed=" + this.confirmed + ", " +
				"submittedForClearing=" + this.submittedForClearing + ", " +
				"updatedForClearing=" + this.updatedForClearing + ", " +
				"cleared=" + this.cleared + ", " +
				"allocationsSubmitted=" + this.allocationsSubmitted + ", " +
				"allocationsUpdated=" + this.allocationsUpdated + ", " +
				"allocationsCompleted=" + this.allocationsCompleted + ", " +
				"timestamp=" + this.timestamp +
			'}';
		}
	}
}
